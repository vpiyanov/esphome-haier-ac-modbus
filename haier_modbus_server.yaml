esphome:
  name: haier-modbus-server
  friendly_name: "Haier AC Modbus Server"

esp32:
  board: esp32dev
  framework:
    type: arduino

# Enable logging
logger:
  level: DEBUG

# Enable Home Assistant API
api:
  encryption:
    key: "i9F3/CGTQ1FtxwJ5FHP8fE5QOUY/DP8n+KeG1iM4dYw="

ota:
  - platform: esphome
    password: "YOUR_OTA_PASSWORD_HERE"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "Haier-Modbus Fallback"
    password: "12345678"

web_server:
  port: 80

# External components for haier-esphome
external_components:
  - source: 
      type: local
      path: ../src/haier-esphome/components
    components: [ haier ]

# UART configuration
uart:
  # UART for Haier air conditioner communication
  - id: haier_uart
    baud_rate: 9600
    tx_pin: GPIO17
    rx_pin: GPIO16
  
  # UART for Modbus server communication
  - id: modbus_uart
    baud_rate: 9600
    tx_pin: GPIO18
    rx_pin: GPIO19

# Modbus server configuration
modbus:
  - uart_id: modbus_uart
    id: modbus_server
    role: server

# Haier climate component
climate:
  - platform: haier
    id: haier_ac
    name: "Haier Air Conditioner"
    uart_id: haier_uart
    protocol: SMARTAIR2
    wifi_signal: true
    display: true
    supported_modes:
      - 'OFF'
      - HEAT_COOL
      - COOL
      - HEAT
      - DRY
      - FAN_ONLY
    supported_swing_modes:
      - 'OFF'
      - VERTICAL
      - HORIZONTAL
      - BOTH
    supported_presets:
      - BOOST
      - COMFORT

# Switches for additional Haier features
switch:
  - platform: template
    id: haier_display_switch
    name: "Haier Display"
    icon: mdi:led-on
    entity_category: config
    restore_mode: RESTORE_DEFAULT_ON
    lambda: |-
      return id(haier_ac).get_display_state();
    turn_on_action:
      - climate.haier.display_on: haier_ac
    turn_off_action:
      - climate.haier.display_off: haier_ac

  # Health mode switch removed - not available in SMARTAIR2 protocol

# Modbus controller with server registers based on ONOKOM-AIR-HR-1-MB-B specification
modbus_controller:
  - modbus_id: modbus_server
    address: 0x1F  # Modbus device address
    server_registers:
      # Coil registers (using holding registers as workaround since coils have issues)
      
      # Address 0x0001 - Active (coil 1)
      - address: 0x0001
        value_type: U_WORD
        read_lambda: |-
          auto mode = id(haier_ac).mode;
          return (mode != CLIMATE_MODE_OFF) ? 1 : 0;
        write_lambda: |-
          if (x != 0) {
            if (id(haier_ac).mode == CLIMATE_MODE_OFF) {
              auto call = id(haier_ac).make_call();
              call.set_mode(CLIMATE_MODE_AUTO);
              call.perform();
            }
          } else {
            auto call = id(haier_ac).make_call();
            call.set_mode(CLIMATE_MODE_OFF);
            call.perform();
          }
          return true;

      # Address 0x0002 - Screen light (coil 2)  
      - address: 0x0002
        value_type: U_WORD
        read_lambda: |-
          return id(haier_display_switch).state ? 1 : 0;
        write_lambda: |-
          if (x != 0) {
            id(haier_display_switch).turn_on();
          } else {
            id(haier_display_switch).turn_off();
          }
          return true;

      # Address 0x0005 - Beeper (coil 5)
      - address: 0x0005
        value_type: U_WORD
        read_lambda: |-
          // Beeper state is not directly accessible in SMARTAIR2, return 1 as default
          return 1;
        write_lambda: |-
          // Beeper control is only available in HON protocol
          // For SMARTAIR2, this is a no-op
          ESP_LOGI("modbus", "Beeper control requested: %d (SMARTAIR2 protocol - no action)", (int)x);
          return true;

      # Holding registers
      
      # Address 0x0001 - Mode (holding register 1)
      - address: 0x0101  # Offset to avoid collision with coils
        value_type: U_WORD
        read_lambda: |-
          auto mode = id(haier_ac).mode;
          switch (mode) {
            case CLIMATE_MODE_HEAT: return 1;
            case CLIMATE_MODE_COOL: return 2;
            case CLIMATE_MODE_HEAT_COOL: return 3;  // Auto mode
            case CLIMATE_MODE_DRY: return 4;
            case CLIMATE_MODE_FAN_ONLY: return 5;
            default: return 1;  // Default to heat
          }
        write_lambda: |-
          auto call = id(haier_ac).make_call();
          switch ((int)x) {
            case 1: call.set_mode(CLIMATE_MODE_HEAT); break;
            case 2: call.set_mode(CLIMATE_MODE_COOL); break;
            case 3: call.set_mode(CLIMATE_MODE_HEAT_COOL); break;
            case 4: call.set_mode(CLIMATE_MODE_DRY); break;
            case 5: call.set_mode(CLIMATE_MODE_FAN_ONLY); break;
            default: call.set_mode(CLIMATE_MODE_AUTO); break;
          }
          call.perform();
          return true;

      # Address 0x0002 - Active mode (holding register 2)
      - address: 0x0102
        value_type: U_WORD
        read_lambda: |-
          auto mode = id(haier_ac).mode;
          switch (mode) {
            case CLIMATE_MODE_OFF: return 0;
            case CLIMATE_MODE_HEAT: return 1;
            case CLIMATE_MODE_COOL: return 2;
            case CLIMATE_MODE_HEAT_COOL: return 3;
            case CLIMATE_MODE_DRY: return 4;
            case CLIMATE_MODE_FAN_ONLY: return 5;
            default: return 0;
          }

      # Address 0x0003 - Indoor air temperature (holding register 3)
      - address: 0x0103
        value_type: S_WORD
        read_lambda: |-
          float temp = id(haier_ac).current_temperature;
          return (int16_t)(temp * 100);  // Scale to 0.01 degree resolution

      # Address 0x0004 - Outdoor air temperature (holding register 4) - disabled
      # Not available in SmartAir2 protocol
      
      # Address 0x0005 - Target temperature (holding register 5)
      - address: 0x0105
        value_type: S_WORD
        read_lambda: |-
          float temp = id(haier_ac).target_temperature;
          return (int16_t)(temp * 100);  // Scale to 0.01 degree resolution
        write_lambda: |-
          float temp = (float)x / 100.0;  // Convert from 0.01 scale
          if (temp >= 16.0 && temp <= 32.0) {
            auto call = id(haier_ac).make_call();
            call.set_target_temperature(temp);
            call.perform();
            return true;
          }
          return false;

      # Address 0x0006 - Thermostat state (holding register 6)
      - address: 0x0106
        value_type: U_WORD
        read_lambda: |-
          auto action = id(haier_ac).action;
          switch (action) {
            case CLIMATE_ACTION_HEATING: return 1;
            case CLIMATE_ACTION_COOLING: return 2;
            default: return 0;  // Idle
          }

      # Address 0x0007 - Fan speed (holding register 7)
      - address: 0x0107
        value_type: U_WORD
        read_lambda: |-
          auto fan = id(haier_ac).fan_mode;
          switch (fan.value_or(CLIMATE_FAN_AUTO)) {
            case CLIMATE_FAN_AUTO: return 0;
            case CLIMATE_FAN_LOW: return 1;
            case CLIMATE_FAN_MEDIUM: return 2;
            case CLIMATE_FAN_HIGH: return 3;
            default: return 0;
          }
        write_lambda: |-
          auto call = id(haier_ac).make_call();
          switch ((int)x) {
            case 0: call.set_fan_mode(CLIMATE_FAN_AUTO); break;
            case 1: call.set_fan_mode(CLIMATE_FAN_LOW); break;
            case 2: call.set_fan_mode(CLIMATE_FAN_MEDIUM); break;
            case 3: call.set_fan_mode(CLIMATE_FAN_HIGH); break;
            default: call.set_fan_mode(CLIMATE_FAN_AUTO); break;
          }
          call.perform();
          return true;

      # Address 0x0009 - Horizontal vanes (holding register 9)
      - address: 0x0109
        value_type: U_WORD
        read_lambda: |-
          auto swing = id(haier_ac).swing_mode;
          if (swing == CLIMATE_SWING_HORIZONTAL || swing == CLIMATE_SWING_BOTH) {
            return 1;  // Swing
          } else {
            return 4;  // Middle position
          }
        write_lambda: |-
          auto call = id(haier_ac).make_call();
          if ((int)x == 1) {
            // Swing mode
            auto current_swing = id(haier_ac).swing_mode;
            if (current_swing == CLIMATE_SWING_VERTICAL) {
              call.set_swing_mode(CLIMATE_SWING_BOTH);
            } else {
              call.set_swing_mode(CLIMATE_SWING_HORIZONTAL);
            }
          } else {
            // Fixed position - turn off horizontal swing
            auto current_swing = id(haier_ac).swing_mode;
            if (current_swing == CLIMATE_SWING_BOTH) {
              call.set_swing_mode(CLIMATE_SWING_VERTICAL);
            } else if (current_swing == CLIMATE_SWING_HORIZONTAL) {
              call.set_swing_mode(CLIMATE_SWING_OFF);
            }
          }
          call.perform();
          return true;

      # Address 0x000A - Vertical vanes (holding register 10)
      - address: 0x010A
        value_type: U_WORD
        read_lambda: |-
          auto swing = id(haier_ac).swing_mode;
          if (swing == CLIMATE_SWING_VERTICAL || swing == CLIMATE_SWING_BOTH) {
            return 1;  // Swing
          } else {
            return 0;  // Stop
          }
        write_lambda: |-
          auto call = id(haier_ac).make_call();
          if ((int)x == 1) {
            // Swing mode
            auto current_swing = id(haier_ac).swing_mode;
            if (current_swing == CLIMATE_SWING_HORIZONTAL) {
              call.set_swing_mode(CLIMATE_SWING_BOTH);
            } else {
              call.set_swing_mode(CLIMATE_SWING_VERTICAL);
            }
          } else {
            // Stop swing
            auto current_swing = id(haier_ac).swing_mode;
            if (current_swing == CLIMATE_SWING_BOTH) {
              call.set_swing_mode(CLIMATE_SWING_HORIZONTAL);
            } else if (current_swing == CLIMATE_SWING_VERTICAL) {
              call.set_swing_mode(CLIMATE_SWING_OFF);
            }
          }
          call.perform();
          return true;

      # Address 0x0014 - Temperature correction (holding register 20)
      - address: 0x0114
        value_type: S_WORD
        read_lambda: |-
          // Temperature correction not directly supported in SmartAir2
          // Return 0 as default
          return 0;
        write_lambda: |-
          // Temperature correction would need custom implementation
          ESP_LOGI("modbus", "Temperature correction: %d", (int)x);
          return true;

# Status LED
status_led:
  pin: GPIO2

# Additional sensors for monitoring
sensor:
  - platform: template
    name: "Haier Current Temperature"
    lambda: |-
      return id(haier_ac).current_temperature;
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    
  - platform: template
    name: "Haier Target Temperature"  
    lambda: |-
      return id(haier_ac).target_temperature;
    unit_of_measurement: "°C"
    accuracy_decimals: 1

text_sensor:
  - platform: template
    name: "Haier Mode"
    lambda: |-
      auto mode = id(haier_ac).mode;
      switch (mode) {
        case CLIMATE_MODE_OFF: return std::string("Off");
        case CLIMATE_MODE_HEAT: return std::string("Heat");
        case CLIMATE_MODE_COOL: return std::string("Cool");
        case CLIMATE_MODE_HEAT_COOL: return std::string("Auto");
        case CLIMATE_MODE_DRY: return std::string("Dry");
        case CLIMATE_MODE_FAN_ONLY: return std::string("Fan");
        default: return std::string("Unknown");
      }

  - platform: template
    name: "Haier Action"
    lambda: |-
      auto action = id(haier_ac).action;
      switch (action) {
        case CLIMATE_ACTION_OFF: return std::string("Off");
        case CLIMATE_ACTION_COOLING: return std::string("Cooling");
        case CLIMATE_ACTION_HEATING: return std::string("Heating");
        case CLIMATE_ACTION_IDLE: return std::string("Idle");
        case CLIMATE_ACTION_DRYING: return std::string("Drying");
        case CLIMATE_ACTION_FAN: return std::string("Fan");
        default: return std::string("Unknown");
      } 