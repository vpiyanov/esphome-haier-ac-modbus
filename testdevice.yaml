esphome:
  name: testdevice
  friendly_name: TestDevice

esp32:
  board: esp32dev
  framework:
    type: arduino

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: "i9F3/CGTQ1FtxwJ5FHP8fE5QOUY/DP8n+KeG1iM4dYw="


ota:
  - platform: esphome
    password: "3cd8dc1b92701bcd0909ad94af44edcc"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Testdevice Fallback Hotspot"
    password: "kRKFGZlIsGRx"

web_server:

captive_portal:


# UART configuration
uart:
  # UART for Haier air conditioner communication
  - id: haier_uart
    baud_rate: 9600
    tx_pin: 19
    rx_pin: 18
  
  # UART for Modbus server communication
  - id: modbus_uart
    baud_rate: 9600
    tx_pin: 17
    rx_pin: 16

# Modbus server configuration
modbus:
  - uart_id: modbus_uart
    id: modbus_server
    role: server

# Haier climate component
climate:
  - platform: haier
    id: haier_ac
    name: "Haier Air Conditioner"
    uart_id: haier_uart
    protocol: SMARTAIR2
    wifi_signal: true
    display: true
    supported_modes:
      - 'OFF'
      - HEAT_COOL
      - COOL
      - HEAT
      - DRY
      - FAN_ONLY
    supported_swing_modes:
      - 'OFF'
      - VERTICAL
      - HORIZONTAL
      - BOTH
    supported_presets: # TODO CLIMATE_PRESET_AWAY
      - BOOST
      - COMFORT

# Switches for additional Haier features
switch:
  - platform: template
    id: haier_ac_health_mode
    name: Health mode
    icon: mdi:leaf
    restore_mode: RESTORE_DEFAULT_ON
    lambda: |-
      return id(haier_ac).get_health_mode();
    turn_on_action:
      climate.haier.health_on: haier_ac
    turn_off_action:
      climate.haier.health_off: haier_ac

  - platform: template
    id: haier_display_switch
    name: "Display"
    icon: mdi:led-on
    entity_category: config
    restore_mode: RESTORE_DEFAULT_ON
    lambda: |-
      return id(haier_ac).get_display_state();
    turn_on_action:
      - climate.haier.display_on: haier_ac
    turn_off_action:
      - climate.haier.display_off: haier_ac

  # Used to store Modbus register values:
  - platform: template
    id: modbus_show_fan_as_range
    name: "[Modbus Coil 92] Show fan as range"
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true

  - platform: template
    id: modbus_show_vanes_as_range
    name: "[Modbus Coil 93] Show vanes as range"
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true

  - platform: template
    id: modbus_show_thermostat_state_as_range
    name: "[Modbus Coil 94] Show thermostat state as range"
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true

  - platform: template
    id: modbus_show_modes_as_range
    name: "[Modbus Coil 95] Show modes as range"
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true

  - platform: restart
    id: restart_switch
    name: "Restart Device"

# Buttons for Modbus address control
button:
  - platform: template
    id: apply_modbus_address_button
    name: "Apply Modbus Address"
    on_press:
      - lambda: |-
          uint8_t address = (uint8_t)id(modbus_address_number).state;
          ESP_LOGI("modbus_address", "Applying Modbus address: %d", address);
          id(modbus_controller_server).set_address(address);

  - platform: template
    id: reset_modbus_address_button
    name: "Reset Modbus Address to Default"
    on_press:
      - number.set:
          id: modbus_address_number
          value: 31  # 0x1F
      - lambda: |-
          ESP_LOGI("modbus_address", "Resetting Modbus address to default: 31");
          id(modbus_controller_server).set_address(31);

select:
  - id: modbus_baud_rate
    name: "[Modbus Holding 110] Baud rate"
    platform: template
    options:
      - "2400"
      - "9600"
      - "38400"
      - "57600"
      - "115200"
      - "256000"
      - "512000"
      - "921600"
    initial_option: "9600"
    optimistic: true
    restore_value: true
    set_action:
      - lambda: |-
          uint32_t new_baud_rate = stoi(x);
          ESP_LOGD("modbus_baud_rate", "Changing baud rate from %i to %i", id(modbus_uart).get_baud_rate(), new_baud_rate);
          if (id(modbus_uart).get_baud_rate() != new_baud_rate) {
            id(modbus_uart).flush();
            id(modbus_uart).set_baud_rate(new_baud_rate);
            id(modbus_uart).load_settings();
          }

  - id: modbus_parity_bit
    name: "[Modbus Holding 111] Parity Bit"
    platform: template
    options:
      - "None"
      - "Odd"
      - "Even"
    initial_option: "None"
    optimistic: true
    restore_value: true
    set_action:
      - lambda: |-
          UARTParityOptions new_parity = UART_CONFIG_PARITY_NONE;
          if (x == "Odd") {
            new_parity = UART_CONFIG_PARITY_ODD;
          } else if (x == "Even") {
            new_parity = UART_CONFIG_PARITY_EVEN;
          }
          ESP_LOGD("modbus_parity", "Changing parity from %i to %i", id(modbus_uart).get_parity(), new_parity);
          if (id(modbus_uart).get_parity() != new_parity) {
            id(modbus_uart).flush();
            id(modbus_uart).set_parity(new_parity);
            id(modbus_uart).load_settings();
          }

  - id: modbus_stop_bits
    name: "[Modbus Holding 112] Stop Bits"
    platform: template
    options:
      - "0"
      - "1"
      - "2"
    initial_option: "2"
    optimistic: true
    restore_value: true
    set_action:
      - lambda: |-
          uint32_t new_stop_bits = stoi(x);
          ESP_LOGD("modbus_stop_bits", "Changing baud rate from %i to %i",id(modbus_uart).get_stop_bits(), new_stop_bits);
          if (id(modbus_uart).get_stop_bits() != new_stop_bits) {
            id(modbus_uart).flush();
            id(modbus_uart).set_stop_bits(new_stop_bits);
            id(modbus_uart).load_settings();
          }

binary_sensor:
  - platform: template
    id: haier_connected_sensor
    name: "AC Connected"
    icon: mdi:led-on
    lambda: |-
      return id(haier_ac).valid_connection();

number:
  # Used to store Modbus register value:
  - platform: template
    id: modbus_temperature_correction_number
    name: "Temperature Correction for Modbus"
    min_value: -10
    max_value: 10
    initial_value: 0.0
    step: 0.1
    restore_value: true
    optimistic: true
    unit_of_measurement: "째C"

  - platform: template
    id: modbus_address_number
    name: "Modbus Address"
    min_value: 1
    max_value: 247
    initial_value: 1
    step: 1
    restore_value: true
    optimistic: true
    set_action:
      - lambda: |-
          ESP_LOGI("modbus_address", "Changing Modbus address to %d", x);
          id(modbus_controller_server).set_address(x);
          ESP_LOGI("modbus_address", "Modbus address successfully changed to %d", x);

# Status LED
status_led:
  pin: GPIO2

# Additional sensors for monitoring
sensor:
  - platform: internal_temperature
    id: mcu_temperature_sensor
    name: "MCU Temperature"
    unit_of_measurement: "째C"
    accuracy_decimals: 1

  - platform: template
    name: "Current Temperature"
    lambda: |-
      return id(haier_ac).current_temperature;
    unit_of_measurement: "째C"
    accuracy_decimals: 1

  - platform: template
    name: "Target Temperature"
    lambda: |-
      return id(haier_ac).target_temperature;
    unit_of_measurement: "째C"
    accuracy_decimals: 1

  - platform: uptime
    id: uptime_sensor
    name: Uptime
    type: seconds

text_sensor:
  - platform: template
    name: "Mode"
    lambda: |-
      auto mode = id(haier_ac).mode;
      switch (mode) {
        case CLIMATE_MODE_OFF: return std::string("Off");
        case CLIMATE_MODE_HEAT: return std::string("Heat");
        case CLIMATE_MODE_COOL: return std::string("Cool");
        case CLIMATE_MODE_HEAT_COOL: return std::string("Auto");
        case CLIMATE_MODE_DRY: return std::string("Dry");
        case CLIMATE_MODE_FAN_ONLY: return std::string("Fan");
        default: return std::string("Unknown");
      }

  - platform: template
    name: "Action TODO" # TODO
    lambda: |-
      auto action = id(haier_ac).action;
      switch (action) {
        case CLIMATE_ACTION_OFF: return std::string("Off");
        case CLIMATE_ACTION_COOLING: return std::string("Cooling");
        case CLIMATE_ACTION_HEATING: return std::string("Heating");
        case CLIMATE_ACTION_IDLE: return std::string("Idle");
        case CLIMATE_ACTION_DRYING: return std::string("Drying");
        case CLIMATE_ACTION_FAN: return std::string("Fan");
        default: return std::string("Unknown");
      } 

# Modbus controller with server registers based on ONOKOM-AIR-HR-1-MB-B specification
modbus_controller:
  - modbus_id: modbus_server
    id: modbus_controller_server
    address: 0x1F  # Modbus device address
    server_registers:
      # Coil registers:

      # Coil 1: Active
      - address: 1
        value_type: COIL
        read_lambda: |-
          return id(haier_ac).mode != CLIMATE_MODE_OFF;
        write_lambda: |-
          if (x) {
            id(haier_ac).send_power_on_command();
          } else {
            id(haier_ac).send_power_off_command();
          }
          return true;

      # Coil 2: Screen light
      - address: 2
        value_type: COIL
        read_lambda: |-
          return id(haier_display_switch).state;
        write_lambda: |-
          if (x) {
            id(haier_display_switch).turn_on();
          } else {
            id(haier_display_switch).turn_off();
          }
          return true;

      # Coil 4: Quiet mode
      - address: 3
        value_type: COIL
        read_lambda: |-
          return id(haier_ac).preset.value_or(NULL) == CLIMATE_PRESET_COMFORT;
        write_lambda: |-
          id(haier_ac).make_call().set_preset(CLIMATE_PRESET_COMFORT).perform();
          return true;

      # Coil 5: Beeper (Not supported in SMARTAIR2)
      - address: 5
        value_type: COIL
        read_lambda: return 0;

      # Coil 7: Turbo mode
      - address: 7
        value_type: COIL
        read_lambda: |-
          return id(haier_ac).preset.value_or(NULL) == CLIMATE_PRESET_BOOST;
        write_lambda: |-
          id(haier_ac).make_call().set_preset(CLIMATE_PRESET_BOOST).perform();
          return true;

      # Coil 8: Sleep mode (Not supported in SMARTAIR2)
      - address: 8
        value_type: COIL
        read_lambda: return 0;

      # Coil 9: Ionization (Not supported in SMARTAIR2)
      - address: 9
        value_type: COIL
        read_lambda: return 0;

      # Coil 10: Self cleaning (Not supported in SMARTAIR2)
      - address: 10
        value_type: COIL
        read_lambda: return 0;

      # Coil 20: AC connected
      - address: 10
        value_type: COIL
        read_lambda: return id(haier_ac).valid_connection();

      # Coil 92: Show fan as range
      - address: 92
        value_type: COIL
        read_lambda: |-
          return id(modbus_show_fan_as_range).state;
        write_lambda: |-
          if (x) {
            id(modbus_show_fan_as_range).turn_on();
          } else {
            id(modbus_show_fan_as_range).turn_off();
          }
          return true;

      # Coil 93: Show vanes as range
      - address: 93
        value_type: COIL
        read_lambda: |-
          return id(modbus_show_vanes_as_range).state;
        write_lambda: |-
          if (x) {
            id(modbus_show_vanes_as_range).turn_on();
          } else {
            id(modbus_show_vanes_as_range).turn_off();
          }
          return true;

      # Coil 94: Show thermostat as range
      - address: 94
        value_type: COIL
        read_lambda: |-
          return id(modbus_show_thermostat_state_as_range).state;
        write_lambda: |-
          if (x) {
            id(modbus_show_thermostat_state_as_range).turn_on();
          } else {
            id(modbus_show_thermostat_state_as_range).turn_off();
          }
          return true;

      # Coil 95: Show modes as range
      - address: 95
        value_type: COIL
        read_lambda: |-
          return id(modbus_show_modes_as_range).state;
        write_lambda: |-
          if (x) {
            id(modbus_show_modes_as_range).turn_on();
          } else {
            id(modbus_show_modes_as_range).turn_off();
          }
          return true;

      # Holding registers:
      
      # Holding 1 - Mode
      - address: 1
        value_type: U_WORD
        read_lambda: |-
          switch (id(haier_ac).mode) {
            case CLIMATE_MODE_HEAT: return 1;
            case CLIMATE_MODE_COOL: return 2;
            case CLIMATE_MODE_HEAT_COOL: return 3;
            case CLIMATE_MODE_DRY: return 4;
            case CLIMATE_MODE_FAN_ONLY: return 5;
            default: return 0;
          }
        write_lambda: |-
          switch (x) {
            case 1: id(haier_ac).make_call().set_mode(CLIMATE_MODE_HEAT).perform(); return true;
            case 2: id(haier_ac).make_call().set_mode(CLIMATE_MODE_COOL).perform(); return true;
            case 3: id(haier_ac).make_call().set_mode(CLIMATE_MODE_HEAT_COOL).perform(); return true;
            case 4: id(haier_ac).make_call().set_mode(CLIMATE_MODE_DRY).perform(); return true;
            case 5: id(haier_ac).make_call().set_mode(CLIMATE_MODE_FAN_ONLY).perform(); return true;
            default: return false;
          }

      # Holding 2 - Active mode
      - address: 2
        value_type: U_WORD
        read_lambda: |-
          switch (id(haier_ac).mode) {
            case CLIMATE_MODE_OFF: return 0;
            case CLIMATE_MODE_HEAT: return 1;
            case CLIMATE_MODE_COOL: return 2;
            case CLIMATE_MODE_HEAT_COOL: return 3;
            case CLIMATE_MODE_DRY: return 4;
            case CLIMATE_MODE_FAN_ONLY: return 5;
            default: return 0;
          }
        write_lambda: |-
          switch (x) {
            case 0: id(haier_ac).make_call().set_mode(CLIMATE_MODE_OFF).perform(); return true;
            case 1: id(haier_ac).make_call().set_mode(CLIMATE_MODE_HEAT).perform(); return true;
            case 2: id(haier_ac).make_call().set_mode(CLIMATE_MODE_COOL).perform(); return true;
            case 3: id(haier_ac).make_call().set_mode(CLIMATE_MODE_HEAT_COOL).perform(); return true;
            case 4: id(haier_ac).make_call().set_mode(CLIMATE_MODE_DRY).perform(); return true;
            case 5: id(haier_ac).make_call().set_mode(CLIMATE_MODE_FAN_ONLY).perform(); return true;
            default: return false;
          }

      # Holding 3 - Indoor air temperature
      - address: 3
        value_type: S_WORD
        read_lambda: |-
          float temp = id(haier_ac).current_temperature;
          float correction = id(modbus_temperature_correction_number).state;
          return (temp + correction) * 100; // Scale to 0.01 degree resolution

      # Holding 4 - Outdoor air temperature (Not supported in SMARTAIR2)
      - address: 4
        value_type: S_WORD
        read_lambda: |-
          return -32768;

      # Holding 5 - Target temperature
      - address: 5
        value_type: S_WORD
        read_lambda: |-
          float temp = id(haier_ac).target_temperature;
          float correction = id(modbus_temperature_correction_number).state;
          return (temp + correction) * 100;  // Scale to 0.01 degree resolution
        write_lambda: |-
          float correction = id(modbus_temperature_correction_number).state;
          float temp = ((float)x) / 100.0;  // Convert from 0.01 scale
          
          id(haier_ac).make_call().set_target_temperature(temp - correction).perform();
          return true;

      # Holding 6 - Thermostat state (TODO)
      - address: 0x0106
        value_type: U_WORD
        read_lambda: |-
          auto action = id(haier_ac).action;
          switch (action) {
            case CLIMATE_ACTION_HEATING: return 1;
            case CLIMATE_ACTION_COOLING: return 2;
            default: return 0;  // Idle
          }

      # Holding 7 - Fan speed
      - address: 7
        value_type: U_WORD
        read_lambda: |-
          switch (id(haier_ac).fan_mode.value_or(CLIMATE_FAN_AUTO)) {
            case CLIMATE_FAN_AUTO: return 0;
            case CLIMATE_FAN_LOW: return 1;
            case CLIMATE_FAN_MEDIUM: return 2;
            case CLIMATE_FAN_HIGH: return 3;
            default: return 0;
          }
        write_lambda: |-
          switch (x) {
            case 0: id(haier_ac).make_call().set_fan_mode(CLIMATE_FAN_AUTO).perform(); return true;
            case 1: id(haier_ac).make_call().set_fan_mode(CLIMATE_FAN_LOW).perform(); return true;
            case 2: id(haier_ac).make_call().set_fan_mode(CLIMATE_FAN_MEDIUM).perform(); return true;
            case 3: id(haier_ac).make_call().set_fan_mode(CLIMATE_FAN_HIGH).perform(); return true;
            default: return false;
          }

      # Holding 8 - Smart fan speed
      - address: 8
        value_type: U_WORD
        read_lambda: |-
          if(id(haier_ac).preset.value_or(NULL) == CLIMATE_PRESET_COMFORT) {
            return 1;
          }          
          if(id(haier_ac).preset.value_or(NULL) == CLIMATE_PRESET_BOOST) {
            return 5;
          }
          switch (id(haier_ac).fan_mode.value_or(CLIMATE_FAN_AUTO)) {
            case CLIMATE_FAN_AUTO: return 0;
            case CLIMATE_FAN_LOW: return 2;
            case CLIMATE_FAN_MEDIUM: return 3;
            case CLIMATE_FAN_HIGH: return 4;
            default: return 0;
          }
        write_lambda: |-
          switch (x) {
            case 0: id(haier_ac).make_call().set_fan_mode(CLIMATE_FAN_AUTO).perform(); return true;
            case 1: id(haier_ac).make_call().set_preset(CLIMATE_PRESET_COMFORT).perform(); return true;
            case 2: id(haier_ac).make_call().set_fan_mode(CLIMATE_FAN_LOW).perform(); return true;
            case 3: id(haier_ac).make_call().set_fan_mode(CLIMATE_FAN_MEDIUM).perform(); return true;
            case 4: id(haier_ac).make_call().set_fan_mode(CLIMATE_FAN_HIGH).perform(); return true;
            case 5: id(haier_ac).make_call().set_preset(CLIMATE_PRESET_BOOST).perform(); return true;
            default: return false;
          }

      # Holding 9 - Horizontal vanes (Not supported in haier-esphome) TODO
      - address: 9
        value_type: U_WORD
        read_lambda: return 0;

      # Holding 10 - Vertical vanes (Not supported in haier-esphome) TODO
      - address: 10
        value_type: U_WORD
        read_lambda: return 0;

      # Holding 11 - Vanes swing TODO alternative_swing_control
      - address: 11
        value_type: U_WORD
        read_lambda: |-
          switch (id(haier_ac).swing_mode) {
            case CLIMATE_SWING_OFF: return 0;
            case CLIMATE_SWING_BOTH: return 1;
            case CLIMATE_SWING_HORIZONTAL: return 2;
            case CLIMATE_SWING_VERTICAL: return 3;
            default: return 0;
          }
        write_lambda: |-
          switch (x) {
            case 0: id(haier_ac).make_call().set_swing_mode(CLIMATE_SWING_OFF).perform(); return true;
            case 1: id(haier_ac).make_call().set_swing_mode(CLIMATE_SWING_BOTH).perform(); return true;
            case 2: id(haier_ac).make_call().set_swing_mode(CLIMATE_SWING_HORIZONTAL).perform(); return true;
            case 3: id(haier_ac).make_call().set_swing_mode(CLIMATE_SWING_VERTICAL).perform(); return true;
            default: return false;
          }

      # Holding 14 - Temperature correction
      - address: 14
        value_type: S_WORD
        read_lambda: |-
          return id(modbus_temperature_correction_number).state * 100;  // Scale to 0.01 degree resolution
        write_lambda: |-
          float temp = ((float)x) / 100.0;  // Convert from 0.01 scale
          id(modbus_temperature_correction_number).make_call().set_value(temp).perform();
          return true;

      # Holding 104 - Uptime
      - address: 104
        value_type: U_WORD
        read_lambda: |-
          return (int)id(uptime_sensor).state;

      # Holding 110 - Baud rate
      - address: 110
        value_type: U_WORD
        read_lambda: |-
          return stoi(id(modbus_baud_rate).state) / 100;
        write_lambda: |-
          std::string baud_rate = std::to_string(x * 100);
          id(modbus_baud_rate).make_call().set_option(baud_rate).perform();
          return true;

      # Holding 111 - Parity Bit
      - address: 111
        value_type: U_WORD
        read_lambda: |-
          std::string parity_bit = id(modbus_parity_bit).state;
          if (parity_bit == "Odd") {
            return 1;
          } else if (parity_bit == "Even") {
            return 2;
          } 
          return 0;
        write_lambda: |-
          switch (x) {
            case 0: id(modbus_parity_bit).make_call().set_option("None").perform(); return true;
            case 1: id(modbus_parity_bit).make_call().set_option("Odd").perform(); return true;
            case 2: id(modbus_parity_bit).make_call().set_option("Even").perform(); return true;
            default: return false;
          }

      # Holding 112 - Stop Bits
      - address: 112
        value_type: U_WORD
        read_lambda: |-
          return stoi(id(modbus_stop_bits).state);
        write_lambda: |-
          std::string stop_bits = std::to_string(x);
          id(modbus_stop_bits).make_call().set_option(stop_bits).perform();
          return true;

      # Holding 120 - Reboot device
      - address: 120
        value_type: U_WORD
        read_lambda: |-
          return 0;
        write_lambda: |-
          if (x == 1) {
            ESP_LOGW("modbus_reboot", "Reboot requested via Modbus register 120");
            id(restart_switch).turn_on();
            return true;
          }
          return false;

      # Holding 128 - Modbus Address
      - address: 128
        value_type: U_WORD
        read_lambda: |-
          return id(modbus_address_number).state;
        write_lambda: |-
          if (x >= 1 && x <= 247) {
            id(modbus_address_number).make_call().set_value((float)x).perform();
            ESP_LOGI("modbus_address", "Modbus address changed via Modbus to: %d", x);
            return true;
          }
          return false;

      # Holding 200 - HW Version
      - address: 200
        value_type: U_WORD
        read_lambda: return 0;

      # Holding 201 - HW Version
      - address: 201
        value_type: U_WORD
        read_lambda: return 0;

      # Holding 250 - FW Version
      - address: 250
        value_type: U_WORD
        read_lambda: return 0;

      # Holding 270 - Serial
      - address: 270
        value_type: U_WORD
        read_lambda: return 0;

      # Input registers:
      
      # Input 124 - MCU Temperature
      - address: 124
        value_type: S_WORD
        read_lambda: |-
          return id(mcu_temperature_sensor).state * 10;  // Scale to 0.1 degree resolution

      # Input 290 - Signature
      - address: 290
        value_type: U_WORD
        read_lambda: return 0;

      # Input 400 - PROTO Version
      - address: 400
        value_type: U_WORD
        read_lambda: return 0;
